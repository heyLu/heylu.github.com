what if we actually started thinking about an interesting future
for personal computing?

- programming languages (less language, more manipulation,
  interaction and exploration)
- systems (too much energy is wasted on getting software to
  communicate, a system should be designed to do this from
  the start)

    * history lessons to be learnt from past system designs
- non-linear, non-organized by default, needs a flexible model
  and have tools to shape structure over time
- everything local by default, syncing is supported but
  additional independent part
- services, not applications (if such distinctions are even
  applicable)
- data at the core, ui is just rendered data, multiple
  possible renderings for pieces of data
- contextual knowledge is encodable/normal, annotations for
  everything (margin notes, synced to video/audio, on any
  kind of document/thing)
- search as an interface to new functionality (e.g. no menu
  searching, but filterable lists of things to do/actions)
- documentation as a core feature of the system, not something
  separate, shown in context, without "effort", first thing
  to learn when getting to know the system
- reification (if we have a type system, then we can ask things
  about types; if we have syntax, then we can parse/generate
  that syntax; ...) to prevent us from using a different system
  to change the system itself
- explorable, some kind of linking facility that works on system
  functionality, documents
- history tree/graph
- an infinite canvas to store things in. or at least throw them
  in and look at them later. partially to not worry about
  organisation when it doesn't matter (having an idea), but also
  to have a common place where things go and to be able to use
  our visual thinking abilities to see patterns later on.
- multiple occurrences of the same thing in one or more structures
  (often things fit in multiple "categories" and "filing" it under
  one of them is unnecessary and might make them not discoverable
  later on)
